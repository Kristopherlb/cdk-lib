Excellent question. This is a critical enterprise use case. Services often need to connect to existing, shared resources (like a central database or a company-wide event bus) that are not managed by their own manifest.
Our platform handles this by using special "import" or "data source" components. These are read-only components whose purpose is not to create new infrastructure, but to look up an existing resource and make its capabilities (like its ARN, endpoint, and security group ID) available to the platform's binding system.
This approach keeps the service.yml manifest fully declarative and consistent. The developer still just binds to a component; they don't need to care if that component is being created from scratch or imported. [cite_start]This aligns with the AWS CDK's own methods for importing existing resources.
Here is what the manifest would look like for your two scenarios.
Scenario 1: Connecting to an Existing Central Database
Let's say a central platform team manages a shared database for your QA environment. Your service needs to connect to it. You would use a component like rds-postgres-import.
 * Action: The developer adds an rds-postgres-import component to their manifest and provides the necessary identifiers to look it up.
 * The lambda-worker then binds to this imported component just like any other.
<!-- end list -->
# service.yml
service: order-processor
owner: team-orders
complianceFramework: commercial
...
components:
  # This component IMPORTS an existing database. It does not create a new one.
  - name: shared-qa-db
    type: rds-postgres-import
    config:
      # Provide the identifiers for the existing database.
      # These values would come from your environment config file (environments.json).
      instanceArn: "arn:aws:rds:us-east-1:123456789012:db:shared-qa-db-instance"
      securityGroupId: "sg-12345678"
      secretArn: "arn:aws:secretsmanager:us-east-1:123456789012:secret:shared-qa-db-creds-AbCdEf"

  - name: my-worker
    type: lambda-worker
    config:
      handler: src/worker.handler
    binds:
      # The binding experience is IDENTICAL. The worker doesn't know or care
      # that the database is an existing resource. It just asks for access.
      - to: shared-qa-db
        capability: db:postgres
        access: readwrite

How it Works Internally:
 * The RdsPostgresImportComponent's synth() method does not create a new rds.DatabaseInstance. Instead, it uses a native CDK lookup method like rds.DatabaseInstance.fromDatabaseInstanceAttributes(...).
 * This creates a read-only, in-memory CDK object that represents the existing database.
 * The LambdaToRdsBinderStrategy receives this object and can still call methods like .connections.allowFrom(...) and .secret.grantRead() on it, which will correctly modify the Lambda's security group and IAM role, but will not modify the existing database itself.
Scenario 2: Connecting to an Existing Pub/Sub Topic
Similarly, if your service needs to publish events to a company-wide new-order-topic managed by another team, you would use an sns-topic-import component.
 * Action: The developer adds the sns-topic-import component, providing the topic's ARN.
 * The lambda-api then binds to it to get permission to publish messages.
<!-- end list -->
# service.yml
service: order-api
owner: team-orders
complianceFramework: commercial
...
components:
  # This component IMPORTS an existing SNS topic.
  - name: central-order-topic
    type: sns-topic-import
    config:
      topicArn: "arn:aws:sns:us-east-1:123456789012:new-order-topic"

  - name: api
    type: lambda-api
    config:
      handler: src/api.handler
    binds:
      # The API binds to the imported topic to get 'write' (publish) permissions.
      - to: central-order-topic
        capability: topic:sns
        access: write

This "import component" pattern ensures that all connections, whether to new or existing resources, are handled through the same secure, declarative, and auditable binding system.
