# Platform Structured Logging Standard

**Version:** 1.0  
**Status:** Published  
**Last Updated:** September 7, 2025

## 1. Overview & Purpose

This document defines the official standard for all application and service logs generated by services running on the platform. It is a mandatory companion to the Platform OpenTelemetry Observability Standard. While the OTel standard defines how telemetry is transported, this document defines what a log event must contain.

The purpose of this standard is to:

- **Ensure all log outputs are in a consistent, structured JSON format**, enabling efficient parsing, searching, and analysis.
- **Guarantee that every log event is automatically correlated** with the service, environment, and specific request (trace) that generated it.
- **Establish a clear vocabulary for log levels** to create a high signal-to-noise ratio in our logging data.
- **Provide a secure framework for handling potentially sensitive information**, in line with compliance requirements like FedRAMP.

## 2. Guiding Principles

### **All Logs are Structured JSON**
Plain text or unstructured log messages are prohibited. Every log output MUST be a single-line JSON object.

### **Logs are Correlated by Default**
Every log event MUST contain identifiers that link it to the service and the specific transaction (trace) it belongs to.

### **The Platform Provides the Logger**
Developers MUST use the platform-provided logging library (`@platform/logger`). The use of `console.log()` or other native print statements for application logging is forbidden.

## 3. The Standard Log Schema

Every log event sent to the central collector MUST conform to the following JSON schema. The platform-provided logger is responsible for automatically enriching logs with the platform-injected fields.

### 3.1. Complete Log Event Structure

```json
{
  "timestamp": "2025-09-07T10:30:00.000Z",
  "level": "INFO",
  "message": "User authentication successful",
  "logger": "auth-service.user-controller",
  "thread": "main",
  "service": {
    "name": "auth-service",
    "version": "2.1.0",
    "instance": "auth-service-7d8f9b2c1a-xyz12"
  },
  "environment": {
    "name": "production",
    "region": "us-west-2",
    "compliance": "fedramp-moderate"
  },
  "trace": {
    "traceId": "abc123def456789012345678",
    "spanId": "789ghi012jkl",
    "sampled": true
  },
  "request": {
    "id": "req_abcdef123456",
    "method": "POST",
    "path": "/api/auth/login",
    "userAgent": "Mozilla/5.0...",
    "remoteIp": "203.0.113.42"
  },
  "user": {
    "id": "user_12345",
    "sessionId": "session_67890",
    "roles": ["user", "customer"]
  },
  "context": {
    "action": "user_authentication",
    "resource": "login_endpoint",
    "component": "lambda-api",
    "operationId": "op_authenticate_user"
  },
  "data": {
    "username": "john.doe",
    "loginMethod": "password",
    "mfaEnabled": true,
    "loginAttempt": 1
  },
  "security": {
    "classification": "cui",
    "piiPresent": false,
    "auditRequired": true
  },
  "performance": {
    "duration": 145,
    "memoryUsed": 23456789,
    "cpuTime": 12
  },
  "error": {
    "type": "ValidationError",
    "code": "AUTH_001",
    "stack": "ValidationError: Invalid credentials\n    at authenticate (/app/auth.js:42:15)",
    "cause": "Invalid password format"
  }
}
```

### 3.2. Field Definitions

#### **Core Fields (Always Present)**

| Field | Type | Description | Example |
|-------|------|-------------|---------|
| `timestamp` | string | ISO 8601 timestamp in UTC | `"2025-09-07T10:30:00.000Z"` |
| `level` | string | Log level (see section 4) | `"INFO"` |
| `message` | string | Human-readable message | `"User authentication successful"` |
| `logger` | string | Logger name/identifier | `"auth-service.user-controller"` |

#### **Service Context (Platform-Injected)**

| Field | Type | Description | Example |
|-------|------|-------------|---------|
| `service.name` | string | Service name from manifest | `"auth-service"` |
| `service.version` | string | Service version | `"2.1.0"` |
| `service.instance` | string | Unique instance identifier | `"auth-service-7d8f9b2c1a-xyz12"` |
| `environment.name` | string | Environment name | `"production"` |
| `environment.region` | string | AWS region | `"us-west-2"` |
| `environment.compliance` | string | Compliance framework | `"fedramp-moderate"` |

#### **Trace Correlation (Platform-Injected)**

| Field | Type | Description | Example |
|-------|------|-------------|---------|
| `trace.traceId` | string | OpenTelemetry trace ID | `"abc123def456789012345678"` |
| `trace.spanId` | string | OpenTelemetry span ID | `"789ghi012jkl"` |
| `trace.sampled` | boolean | Whether trace is sampled | `true` |

#### **Request Context (Auto-Populated for HTTP)**

| Field | Type | Description | Example |
|-------|------|-------------|---------|
| `request.id` | string | Unique request identifier | `"req_abcdef123456"` |
| `request.method` | string | HTTP method | `"POST"` |
| `request.path` | string | Request path | `"/api/auth/login"` |
| `request.userAgent` | string | User agent (sanitized) | `"Mozilla/5.0..."` |
| `request.remoteIp` | string | Client IP (anonymized if required) | `"203.0.113.42"` |

#### **User Context (When Available)**

| Field | Type | Description | Example |
|-------|------|-------------|---------|
| `user.id` | string | User identifier | `"user_12345"` |
| `user.sessionId` | string | Session identifier | `"session_67890"` |
| `user.roles` | array | User roles | `["user", "customer"]` |

#### **Application Context (Developer-Provided)**

| Field | Type | Description | Example |
|-------|------|-------------|---------|
| `context.action` | string | Business action being performed | `"user_authentication"` |
| `context.resource` | string | Resource being acted upon | `"login_endpoint"` |
| `context.component` | string | Platform component type | `"lambda-api"` |
| `context.operationId` | string | Unique operation identifier | `"op_authenticate_user"` |

#### **Application Data (Developer-Provided)**

| Field | Type | Description | Example |
|-------|------|-------------|---------|
| `data.*` | any | Business-specific data (sanitized) | `{"username": "john.doe", "loginMethod": "password"}` |

#### **Security Context (Platform-Managed)**

| Field | Type | Description | Example |
|-------|------|-------------|---------|
| `security.classification` | string | Data classification level | `"cui"` |
| `security.piiPresent` | boolean | Whether PII is present | `false` |
| `security.auditRequired` | boolean | Whether audit logging is required | `true` |

#### **Performance Metrics (Auto-Collected)**

| Field | Type | Description | Example |
|-------|------|-------------|---------|
| `performance.duration` | number | Operation duration in milliseconds | `145` |
| `performance.memoryUsed` | number | Memory usage in bytes | `23456789` |
| `performance.cpuTime` | number | CPU time in milliseconds | `12` |

#### **Error Information (When Applicable)**

| Field | Type | Description | Example |
|-------|------|-------------|---------|
| `error.type` | string | Error type/class | `"ValidationError"` |
| `error.code` | string | Application error code | `"AUTH_001"` |
| `error.stack` | string | Stack trace (sanitized) | `"ValidationError: Invalid credentials..."` |
| `error.cause` | string | Root cause description | `"Invalid password format"` |

## 4. Log Levels

The platform uses a five-level logging hierarchy. Each level has specific semantic meaning and usage guidelines.

### 4.1. Level Definitions

| Level | Numeric Value | Purpose | When to Use |
|-------|---------------|---------|-------------|
| `ERROR` | 50 | System errors, failures, exceptions | Unhandled exceptions, failed operations, system failures |
| `WARN` | 40 | Warning conditions, potential issues | Deprecated API usage, configuration warnings, recoverable errors |
| `INFO` | 30 | Informational messages, business events | User actions, business transactions, service lifecycle events |
| `DEBUG` | 20 | Detailed diagnostic information | Variable values, control flow, detailed operation steps |
| `TRACE` | 10 | Extremely detailed execution flow | Function entry/exit, loop iterations, fine-grained execution |

### 4.2. Level Usage Guidelines

#### **ERROR Level**
- **Purpose:** Indicates something has gone wrong and requires immediate attention
- **Examples:**
  - Unhandled exceptions that cause request failures
  - Database connection failures
  - External service timeouts
  - Security violations or authentication failures
- **Compliance:** ERROR logs trigger immediate alerts in FedRAMP environments

#### **WARN Level**
- **Purpose:** Indicates potential issues or unusual conditions that don't prevent operation
- **Examples:**
  - Deprecated API endpoints being used
  - Performance thresholds being approached
  - Configuration values falling back to defaults
  - Retry attempts before final failure
- **Compliance:** WARN logs are aggregated for trend analysis

#### **INFO Level**
- **Purpose:** Records normal business operations and lifecycle events
- **Examples:**
  - User login/logout events
  - Business transactions completed
  - Service startup/shutdown
  - Configuration changes applied
- **Compliance:** INFO logs provide audit trail for business operations

#### **DEBUG Level**
- **Purpose:** Provides detailed diagnostic information for troubleshooting
- **Examples:**
  - Variable values at key decision points
  - Control flow through business logic
  - External API request/response details
  - Cache hit/miss information
- **Production:** Disabled by default in production for performance

#### **TRACE Level**
- **Purpose:** Extremely detailed execution flow for deep debugging
- **Examples:**
  - Function entry and exit
  - Loop iterations and conditions
  - State transitions
  - Fine-grained performance measurements
- **Production:** Never enabled in production environments

### 4.3. Dynamic Log Level Control

Log levels can be adjusted at runtime without service restart:

- **Environment Variable:** `PLATFORM_LOG_LEVEL=INFO`
- **Component Override:** `PLATFORM_LOG_LEVEL_LAMBDA_API=DEBUG`
- **Runtime API:** `POST /admin/logging/level {"level": "DEBUG", "component": "auth"}`

## 5. Platform Logger Library Specification

### 5.1. Logger Interface

The platform provides a standardized logger interface that automatically handles correlation, formatting, and security:

```typescript
import { Logger } from '@platform/logger';

const logger = Logger.getLogger('user-service.auth-controller');

// Basic logging
logger.info('User authentication successful', {
  context: { action: 'user_authentication', resource: 'login_endpoint' },
  data: { username: 'john.doe', loginMethod: 'password' }
});

// Error logging with automatic stack trace capture
logger.error('Authentication failed', error, {
  context: { action: 'user_authentication', resource: 'login_endpoint' },
  data: { username: 'john.doe', attempt: 3 }
});

// Performance logging with automatic timing
const timer = logger.startTimer();
await performOperation();
timer.finish('Operation completed', {
  context: { action: 'data_processing', resource: 'user_profile' }
});

// Conditional logging for performance
if (logger.isDebugEnabled()) {
  logger.debug('Detailed processing steps', {
    data: { steps: complexCalculation() }
  });
}
```

### 5.2. Automatic Data Sanitization

The platform logger automatically sanitizes sensitive data based on compliance requirements:

```typescript
// PII is automatically detected and redacted
logger.info('User profile updated', {
  data: {
    userId: 'user_12345',
    email: 'john.doe@example.com',  // Automatically redacted to 'j***@***.com'
    phone: '+1-555-0123',           // Automatically redacted to '+1-***-****'
    ssn: '123-45-6789'              // Automatically redacted to '***-**-****'
  }
});

// Credit card numbers are automatically detected and redacted
logger.info('Payment processed', {
  data: {
    cardNumber: '4111-1111-1111-1111', // Automatically redacted to '****-****-****-1111'
    amount: 99.99,
    currency: 'USD'
  }
});
```

### 5.3. Compliance Framework Integration

Logging behavior automatically adjusts based on the deployment compliance framework:

```typescript
// Automatic retention and encryption based on compliance framework
switch (complianceFramework) {
  case 'fedramp-high':
    // - 7 year retention
    // - Customer-managed KMS encryption
    // - Immutable audit logs
    // - Real-time SIEM integration
    break;
  case 'fedramp-moderate':
    // - 3 year retention
    // - AWS-managed encryption
    // - Enhanced monitoring
    // - Daily compliance reports
    break;
  default:
    // - 1 year retention
    // - Standard encryption
    // - Basic monitoring
    // - Weekly reports
}
```

## 6. Component-Specific Logging Patterns

### 6.1. Lambda Function Logging

```typescript
// Automatic Lambda context injection
export const handler = async (event: APIGatewayProxyEvent, context: Context) => {
  const logger = Logger.getLogger('user-service.lambda');
  
  // Request start - automatically includes Lambda context
  logger.info('Processing request', {
    context: { action: 'api_request', resource: 'user_endpoint' },
    data: { 
      path: event.path,
      method: event.httpMethod,
      requestId: context.awsRequestId
    }
  });
  
  try {
    const result = await processRequest(event);
    
    // Success logging
    logger.info('Request processed successfully', {
      context: { action: 'api_response', resource: 'user_endpoint' },
      data: { statusCode: 200, responseSize: JSON.stringify(result).length }
    });
    
    return result;
  } catch (error) {
    // Error logging with automatic Lambda error context
    logger.error('Request processing failed', error, {
      context: { action: 'api_error', resource: 'user_endpoint' },
      data: { 
        requestId: context.awsRequestId,
        remainingTime: context.getRemainingTimeInMillis()
      }
    });
    
    throw error;
  }
};
```

### 6.2. Database Operation Logging

```typescript
// Database operation logging with automatic query sanitization
class DatabaseService {
  private logger = Logger.getLogger('user-service.database');
  
  async findUser(userId: string): Promise<User> {
    const timer = this.logger.startTimer();
    
    try {
      this.logger.debug('Executing database query', {
        context: { action: 'database_query', resource: 'users_table' },
        data: { 
          operation: 'SELECT',
          table: 'users',
          userId: userId // userId is automatically sanitized based on PII rules
        }
      });
      
      const user = await this.db.findById(userId);
      
      timer.finish('Database query completed', {
        context: { action: 'database_result', resource: 'users_table' },
        data: { found: !!user, queryTime: timer.elapsed() }
      });
      
      return user;
    } catch (error) {
      this.logger.error('Database query failed', error, {
        context: { action: 'database_error', resource: 'users_table' },
        data: { operation: 'SELECT', table: 'users', userId }
      });
      
      throw error;
    }
  }
}
```

### 6.3. Message Queue Logging

```typescript
// SQS message processing with automatic correlation
class MessageProcessor {
  private logger = Logger.getLogger('user-service.queue');
  
  async processMessage(message: SQSMessage): Promise<void> {
    // Extract trace context from message attributes
    const traceContext = extractTraceFromMessage(message);
    
    this.logger.info('Processing queue message', {
      context: { action: 'message_processing', resource: 'user_updates_queue' },
      data: {
        messageId: message.MessageId,
        receiptHandle: message.ReceiptHandle?.substring(0, 20) + '...', // Truncate for security
        messageSize: message.Body?.length || 0,
        approximateReceiveCount: message.Attributes?.ApproximateReceiveCount
      },
      trace: traceContext
    });
    
    try {
      await this.handleMessage(JSON.parse(message.Body || '{}'));
      
      this.logger.info('Message processed successfully', {
        context: { action: 'message_success', resource: 'user_updates_queue' },
        data: { messageId: message.MessageId }
      });
      
    } catch (error) {
      this.logger.error('Message processing failed', error, {
        context: { action: 'message_error', resource: 'user_updates_queue' },
        data: { 
          messageId: message.MessageId,
          retryCount: parseInt(message.Attributes?.ApproximateReceiveCount || '1')
        }
      });
      
      // Send to DLQ after max retries
      if (parseInt(message.Attributes?.ApproximateReceiveCount || '1') >= 3) {
        this.logger.warn('Message sent to dead letter queue', {
          context: { action: 'message_dlq', resource: 'user_updates_dlq' },
          data: { messageId: message.MessageId, finalRetry: true }
        });
      }
      
      throw error;
    }
  }
}
```

## 7. Security and Compliance Requirements

### 7.1. Data Classification and Handling

#### **CUI (Controlled Unclassified Information)**
- Automatic detection and redaction of PII fields
- Enhanced encryption at rest and in transit
- Restricted access with RBAC controls
- Immutable audit trails

#### **PII (Personally Identifiable Information)**
- Email addresses: `j***@***.com`
- Phone numbers: `+1-***-****`
- SSN: `***-**-****`
- Credit cards: `****-****-****-1111`

#### **PHI (Protected Health Information)**
- Medical record numbers: `MRN-****-****`
- Insurance IDs: `INS-****-****`
- Prescription data: Completely redacted

### 7.2. Audit and Retention Requirements

#### **FedRAMP High Requirements**
- **Retention:** 7 years minimum
- **Immutability:** Write-once, read-many (WORM) storage
- **Encryption:** Customer-managed KMS keys
- **Access:** All access logged with full attribution
- **Integrity:** Cryptographic signatures for tamper detection

#### **FedRAMP Moderate Requirements**
- **Retention:** 3 years minimum
- **Encryption:** AWS-managed keys with rotation
- **Access:** Role-based access controls
- **Monitoring:** Real-time compliance dashboards

#### **Commercial Requirements**
- **Retention:** 1 year standard
- **Encryption:** Standard AWS encryption
- **Access:** Basic authentication and authorization
- **Monitoring:** Standard operational dashboards

### 7.3. Real-Time Security Monitoring

```typescript
// Automatic security event detection
logger.info('User login attempt', {
  context: { action: 'authentication', resource: 'login_endpoint' },
  data: { username: 'john.doe', source: 'web', mfa: true },
  security: {
    classification: 'cui',
    auditRequired: true,
    securityEvent: 'user_authentication' // Triggers real-time SIEM alert
  }
});

// Suspicious activity automatic flagging
logger.warn('Multiple failed login attempts', {
  context: { action: 'security_violation', resource: 'login_endpoint' },
  data: { username: 'john.doe', attempts: 5, timeWindow: '5min' },
  security: {
    classification: 'cui',
    auditRequired: true,
    securityEvent: 'brute_force_attempt', // Triggers immediate security response
    riskLevel: 'high'
  }
});
```

## 8. Performance and Efficiency

### 8.1. Asynchronous Logging

All log writes are asynchronous to minimize application latency:

```typescript
// High-performance async logging with batching
const logger = Logger.getLogger('high-throughput-service');

// Logs are buffered and sent in batches
logger.info('High frequency event', { data: { eventId: 12345 } }); // < 1ms impact

// Force flush for critical events
await logger.flush(); // Ensures critical logs are immediately sent
```

### 8.2. Intelligent Sampling

Automatic log sampling based on volume and compliance requirements:

```typescript
// Automatic sampling configuration
const samplingConfig = {
  'ERROR': 1.0,   // 100% of error logs
  'WARN': 1.0,    // 100% of warning logs
  'INFO': 0.1,    // 10% of info logs (commercial), 100% (FedRAMP)
  'DEBUG': 0.01,  // 1% of debug logs (when enabled)
  'TRACE': 0.001  // 0.1% of trace logs (when enabled)
};
```

### 8.3. Resource Management

Automatic log rotation and cleanup:

```typescript
// Automatic log file management
const logConfig = {
  maxFileSize: '100MB',
  maxFiles: 10,
  compressOldFiles: true,
  retentionDays: getRetentionDays(complianceFramework)
};
```

## 9. Implementation Verification

### 9.1. Automatic Compliance Checks

Each component must pass the following logging compliance checks:

1. **Schema Validation:** All log events conform to the standard JSON schema
2. **Correlation Presence:** All logs contain valid trace and service correlation IDs
3. **PII Redaction:** Sensitive data is properly redacted based on classification rules
4. **Security Events:** Security-relevant events are properly classified and flagged
5. **Retention Compliance:** Log retention matches compliance framework requirements

### 9.2. Log Quality Metrics

Automated monitoring of log quality:

- **Signal-to-Noise Ratio:** High-value logs vs. verbose debug output
- **Correlation Rate:** Percentage of logs with valid trace correlation
- **Security Coverage:** Percentage of security events properly classified
- **Compliance Rate:** Percentage of logs meeting retention and encryption requirements

### 9.3. Developer Tools

Built-in tools for log analysis and debugging:

```bash
# Platform CLI for log analysis
platform logs search --service auth-service --level ERROR --last 1h
platform logs trace --trace-id abc123def456 --format json
platform logs compliance --framework fedramp-high --audit-period 30d
```

---

## Conclusion

The Platform Structured Logging Standard ensures that every log event across our platform is consistent, correlatable, secure, and compliance-ready. By mandating the use of the platform-provided logger and enforcing structured JSON output, we create a foundation for effective observability, security monitoring, and regulatory compliance.

This standard is **mandatory** for all platform components and **cannot be circumvented** - structured logging is a fundamental platform service, not an optional feature.