
Post-Development QA Checklist – Shinobi Platform Compliance & Alignment

Platform Components

Lambda Functions (API & Worker): Ensure AWS Lambda-based components (lambda-api, lambda-worker) implement all platform standards. Validation: Verify Lambdas run in a VPC by default, have AWS X-Ray tracing enabled, and attach the AWS Distro for OpenTelemetry (ADOT) layer for telemetry. Confirm CloudWatch log retention is set to a default (e.g. 14 days) instead of “Never Expire”. Standard: Platform FR-10 security defaults (tracing on, VPC by default, log retention); OpenTelemetry Observability Standard. Requirement: Required (FedRAMP-high & all deployments). Status: Implemented – Lambda component sets tracing: ACTIVE, default VPC networking, and adds OTel tracing layers (per code standards).

S3 Bucket Component: Ensure S3 buckets adhere to secure defaults. Validation: Confirm buckets are private (no public ACLs) and versioning is enabled by default. Verify server-access logging to a designated log bucket is enabled for FedRAMP deployments (FedRAMP Moderate/High requires access logs). Check that bucket encryption is enabled (SSE-S3 by default, or KMS CMK if FedRAMP). Standard: FR-10 (S3 default private, encrypted, versioning on); FedRAMP policy pack (e.g. requires access logging). Requirement: Required (enforced in FedRAMP; warnings in commercial). Status: Implemented – Platform defaults enforce private, encrypted buckets with versioning; Needs Review – FedRAMP logging (should fail plan if missing).

RDS Postgres Component: Ensure relational databases meet platform hardening standards. Validation: Verify RDS instances have storage encryption enabled (AWS-managed KMS key by default, auto-switched to Customer-managed CMK for FedRAMP). Check deletion protection is on by default, and instances are deployed in private subnets (no public IP). In FedRAMP-High, confirm use of FIPS 140-2 validated endpoints and that enhanced auditing is enabled (e.g. database audit logs to CloudWatch/central logging). Standard: FR-10 (RDS encrypted, deletion-protected, subnet-restricted); FedRAMP AC-C2/AC-C3 (CMK with rotation, FIPS endpoints, audit logging). Requirement: Required (FedRAMP-high mandatory; defaults apply platform-wide). Status: Partially Implemented – Encryption, deletion protection and subnet defaults in place; FedRAMP-specific audit configs pending (to be built or verified in policy).

SQS Queue Component: Ensure queuing components follow platform guidelines. Validation: Confirm every SQS queue has a Dead-Letter Queue (DLQ) automatically created and configured. Verify server-side encryption is enabled (KMS-managed encryption by default). Check that any FedRAMP-specific settings (e.g. stricter DLQ retention or KMS CMK usage) are applied when complianceFramework is fedramp-high. Standard: FR-10 (SQS DLQ by default). Requirement: Required (enterprise standard, FedRAMP). Status: Implemented – Platform creates and binds a DLQ by default; KMS encryption uses AWS-managed key (upgrade to CMK under FedRAMP per FR-11).

DynamoDB Table Component: Validate NoSQL database components for compliance. Validation: Verify DynamoDB tables have encryption at rest enabled (AWS-owned key by default; CMK if FedRAMP-high). Check that Point-in-Time Recovery (PITR) is enabled by default for resilience (if not, suggest enabling by policy). Ensure data-classification tags are provided on all DynamoDB components (platform policy requires classifying data sensitivity). Standard: Platform Tagging Standard (data-classification mandatory for databases); FedRAMP security baseline (encryption). Requirement: Required (FedRAMP-high, recommended generally). Status: Partially Implemented – Encryption is default (AWS-managed); Not enforced – PITR default and classification tag enforcement rely on policy (OPA).

SNS Topic Component: Ensure pub/sub topics meet platform requirements. Validation: Check SNS topics have encryption enabled (AWS-managed KMS key by default, use CMK in FedRAMP contexts per standards). Verify topics are private (no broad unauthorized subscriptions) and that any inter-service publish/subscribe follows approved patterns. Confirm that if a topic triggers other components via the triggers configuration, the appropriate subscriptions and permissions are synthesized. Standard: FR-11 cross-framework defaults (e.g., CMK for FedRAMP); Binding/Trigger Spec for SNS triggers. Requirement: Required for encryption (FedRAMP); Suggested for others. Status: Implemented – Encryption default applied; Needs Verification – trigger handling logic for SNS (should be implemented as per spec).

EventBridge Rule Component: Ensure scheduled event triggers align with platform design. Validation: Confirm eventbridge-rule components (e.g. cron schedulers) support the triggers configuration to invoke targets. When a rule targets a Lambda or SQS, verify the CDK targets.LambdaFunction or targets.SqsQueue is used and necessary permissions created. Ensure rules are always encrypted (EventBridge rules use AWS-managed event bus by default) and, if FedRAMP, that the event bus is not public. Standard: Trigger Matrix (EventBridge->Lambda/SQS). Requirement: Required (for functionality; security defaults FedRAMP). Status: Implemented – Basic scheduling triggers exist per spec; Pending – encryption and advanced FedRAMP checks on event buses.

ECS Fargate Service Component: (If present) Validate container service components. Validation: Ensure any ECS/Fargate service automatically injects an ADOT Collector sidecar container for telemetry. Check that tasks run in private subnets with no public IP, and security groups are locked down to only required ports. Verify that if complianceFramework is fedramp-high, the ECS task definition enforces using only approved images and that the sidecar uses FIPS-compliant endpoints. Standard: OpenTelemetry Standard (ECS sidecar injection); general FedRAMP network hardening. Requirement: Required (FedRAMP-high, observability). Status: Not Implemented – ECS component is planned (observability spec defined) but not yet in repo (to be added to backlog).

EC2/Auto-Scaling Components: (If present) Ensure VM-based components meet baseline. Validation: Verify ec2-instance and auto-scaling-group components install the ADOT agent in the User Data bootstrap. Check that instances default to hardened AMIs (e.g. latest Amazon Linux 2 or CIS-hardened if FedRAMP) and are launched with IMDSv2 enforced. Confirm security groups restrict ingress to only allowed sources (least privilege networking). Standard: OpenTelemetry Standard (EC2 ADOT agent); FedRAMP (least privilege, CIS baseline). Requirement: Required (FedRAMP-high, observability). Status: Not Implemented – EC2 components are conceptual in spec but not yet in this codebase (monitor as future enhancement).


Component-Level Checks

Tagging – Mandatory Platform Tags: Verify every AWS resource created by any component has the standard platform tags applied: platform:service-name, platform:owner, platform:component-name, platform:component-type, platform:environment, platform:managed-by, and platform:commit-hash. These tags must auto-populate from the service manifest and deployment context. Standard: Platform Tagging Standard v1.0. Requirement: Required (enterprise & FedRAMP mandatory). Status: Implemented – ResolverEngine tags the root stack with all mandatory tags, which propagate to child resources.

Tagging – Consistent Format & Inheritance: Check that tag keys use kebab-case and values conform to expected format (case-sensitive). All taggable child resources should inherit the tags from the parent CDK Stack by design – verify this occurs (no components creating resources outside stack scope without tags). Standard: Platform Tagging Standard (case and propagation rules). Requirement: Required. Status: Implemented – Tagging is automated; any deviation (e.g. missing tags on a resource) is caught by policy-as-code validation.

Tagging – Data Classification: For all storage and database components (e.g. S3 buckets, RDS instances, DynamoDB tables), ensure a data-classification label is provided in the manifest (e.g. labels: { data-classification: "pii" }). The allowed values should be one of the approved list: public, internal, confidential, pii. Standard: Platform Tagging Standard (data-classification mandatory for storage). Requirement: Required (FedRAMP and internal policy). Status: Enforced via Policy – Not auto-set by code, but the planning phase fails if a storage component lacks this tag.

Tagging – Compliance Framework Tags: Verify that when complianceFramework is fedramp-moderate or fedramp-high, the platform automatically applies the tags compliance:framework (e.g. “fedramp-high”) and compliance:ssp-id to all resources. The SSP ID should come from environment config (ensure each FedRAMP environment has an SSP identifier configured). Standard: Platform Tagging Standard (Compliance-Specific Tags). Requirement: Required (FedRAMP-only). Status: Implemented – Framework tag auto-derived from manifest; SSP ID tag is applied if environment data is provided (needs environment setup).

Observability – OpenTelemetry Instrumentation: Check that all compute components (Lambdas, ECS tasks, EC2 instances, etc.) automatically include OpenTelemetry instrumentation. For Lambdas, confirm the ADOT Lambda Layer is added for the runtime; for ECS, a sidecar container is injected; for EC2, the Collector agent is installed via UserData. Standard: Platform OTel Observability Standard. Requirement: Required (not optional per standard). Status: Implemented for Lambda (layer added in synth); Pending for ECS/EC2 (to be fully developed per spec).

Observability – Telemetry Config: Validate that each environment in environments.json provides a central otelCollectorEndpoint and that the platform passes it to components. During synth/plan, ensure the OTEL_EXPORTER_OTLP_ENDPOINT env var on compute resources is set to this URL. Also verify the platform injects OTEL_SERVICE_NAME (set to the service name) and OTEL_RESOURCE_ATTRIBUTES (including environment and owner metadata) for each service. Standard: OTel Observability Standard (Central Collector Config, Standard Env Vars). Requirement: Required. Status: Implemented – Context hydration provides the OTel config to all components; check output templates to confirm env vars present.

Observability – FedRAMP Enhancements: In FedRAMP modes, ensure elevated observability settings are in effect. Validation: Confirm AWS X-Ray tracing is enabled on all Lambdas and other compute by default (this should be auto-configured in construct props). Verify that application logs are correlated with trace IDs – e.g., trace ID injection is configured (via logger or Lambda Powertools) so that each log entry includes the active traceId. Ensure log output is structured JSON with required audit fields (timestamp, request ID, user, etc.) in compliance deployments. Standard: Observability Standard – FedRAMP Integration. Requirement: Required (FedRAMP-high). Status: Partially Implemented – X-Ray enabled and structured logging recommended by standard, but Needs Implementation – full log correlation/JSON formatting may require additional libraries or configuration (backlog item for FedRAMP logging standard).

Logging – CloudWatch Log Retention: Verify that all CloudWatch Log Groups created by platform components have an explicit retention period set (e.g. 90 days for prod, shorter for dev) rather than infinite retention. This applies to Lambda function logs, API Gateway access logs, etc. Standard: Security best practice (log retention), implied by FR-10. Requirement: Required (FedRAMP-high requires log retention limits). Status: Implemented – Lambda constructs default to a retention period (check code or cdk-nag output); Confirm – ensure any log group without explicit setting is caught by cdk-nag.

Logging – S3 Access Logging: Ensure that for any S3 bucket in a FedRAMP context, Server Access Logging is enabled to a designated logging bucket. This includes platform-internal buckets (if any) as well as user-defined. If the platform has a central logging bucket, verify that it’s used by default. Standard: FedRAMP Moderate control (AC-G2 in policy pack). Requirement: Required (FedRAMP Moderate/High; optional for others). Status: Enforced via Policy – If a FedRAMP deployment lacks access logging, svc plan fails with an error; platform may not auto-enable it yet (requires pre-provisioned log bucket).

Security – Encryption at Rest: Confirm all components encrypt data at rest by default. This includes S3 buckets (SSE enabled), EBS volumes or EFS (if any EC2/ECS uses storage), SQS queues (SSE), SNS topics (KMS encryption), and all database storage. In FedRAMP modes, encryption must use customer-managed KMS CMKs where applicable (e.g. S3, RDS, DynamoDB). In commercial mode, AWS-managed keys are acceptable defaults. Standard: FedRAMP policy (KMS CMK for Moderate/High); FR-11 cross-framework defaults. Requirement: Required (enforced by policy packs per framework). Status: Implemented – Default encryption is on in all components; switching to CMKs in FedRAMP is implemented in config builders (e.g. use of platform CMK).

Security – Least Privilege IAM: Inspect IAM policies and roles generated for each component to ensure least privilege. Validation: Each Lambda or compute role should only include the permissions needed for its declared binds/triggers. No wildcard (“*”) actions on resource ARNs except where unavoidable. For example, a Lambda binding to an S3 bucket with access: read should only have s3:GetObject (and List if needed) on that bucket, not write permissions. Security groups for bindings (e.g. Lambda to RDS) must restrict network access to the specific source/destination pair and port (e.g. allow Lambda SG to DB SG on 5432 only). Standard: FedRAMP least privilege & Binding Spec (principle of least privilege for binds). Requirement: Required (FedRAMP-high critical control). Status: Implemented – Binder classes generate minimal IAM statements (verified via IAM audit examples); security group rules are configured per binder (needs review for completeness).

Security – IAM Auditing Setup: Ensure the groundwork for IAM auditing is in place. Validation: Check that CloudTrail is enabled for all accounts/environments by the platform baseline (so that IAM usage data is available). Confirm that each binding’s IAM policy is attached in a way that can be traced (e.g. unique policy naming or tagging for audit). While the svc audit iam command may not be fully implemented, ensure that the platform at least tags or identifies IAM roles by service/component to facilitate off-line audit queries. Standard: Platform IAM Auditing Standard. Requirement: Required (FedRAMP Moderate/High, auditability). Status: Partially Implemented – CloudTrail baseline expected (outside repo scope); IAM roles are named per service-component, enabling CloudTrail filtering (the automated audit tool is a backlog item).

Testing – Unit Coverage: Verify that each component package includes unit tests and, where appropriate, snapshot tests of the synthesized CloudFormation. Validation: For each package in packages/components/*, check for a tests/ directory with meaningful test cases (e.g. verifying that default config produces expected CFN resources, that invalid config is handled gracefully). Standard: NFR-3 (Components must pass unit & snapshot tests). Requirement: Required (platform quality standard). Status: Implemented – Most core components have accompanying tests (failing tests would block CI); Monitor – ensure new components cannot be merged without tests (CI enforcement).

Testing – cdk-nag Compliance: Confirm that the AWS CDK Nag checks run against all synthesized templates and that there are no undisclosed high-severity findings. All NagSuppressions used in code must include a justification, an owner, and expiry date. Validation: Run cdk-nag (or svc plan) in FedRAMP mode and verify it fails on any critical violation (e.g. unencrypted resource, public bucket). In commercial mode, verify that cdk-nag warnings are either suppressed with justification or appear in plan output as informational (not blockers). Standard: FR-7 (suppressions require metadata); FR-9 (fail on critical FedRAMP violations); Acceptance AC-G1/G2/G3. Requirement: Required (especially FedRAMP-high). Status: Implemented – Governance engine loads appropriate rule packs; plan fails if critical rules violated; suppression fields enforced.

Configuration – Precedence Chain: Validate the configuration layering logic for environment-specific overrides. Validation: For a given service and environment, ensure the final synthesized config reflects the merge of platform defaults, compliance defaults, global env settings, service-level env overrides, and component overrides in the correct order (Layer 1 through 5). For example, a property overridden in components[x].overrides should take highest precedence, even over FedRAMP defaults, allowing opt-in to stricter settings. Conversely, compliance defaults should override base defaults. Test by specifying a cross-framework override (e.g. specifying a CMK in a commercial deployment) and confirm it’s honored. Standard: Configuration Precedence Chain documentation; AC-C4 (cross-framework override). Requirement: Required (to ensure predictability). Status: Implemented – Each component’s ConfigBuilder implements getPlatformDefaults() and getComplianceFrameworkDefaults() for layering; merging logic in context hydration follows the documented chain.

Configuration – Environment Context: Verify that environments.json is properly used to inject environment-specific context. Validation: Ensure that account IDs, regions, VPC IDs, and default KMS keys from environments.json are loaded and applied during synth for the target --env. For example, deploying to “prod-us-west-2” should pick up the prod account, region, and any default resources defined for that env. The PlatformContext (or similar) should make these available to components (e.g. default VPC or KMS ARN). Standard: Configuration Precedence (Global Environment Configuration). Requirement: Required. Status: Implemented – Context hydrator reads environments.json and populates env config (check that missing entries are handled with errors).

Configuration – Service-Level Overrides: Ensure that the environments: block in service manifests functions correctly. Validation: Define differing defaults for a component in dev vs prod in a test manifest and run svc plan for each env, confirming the differences are reflected (e.g. instance size, scaling limits). Also verify that the syntax ${env:KEY} properly interpolates environment-specific values in component configs. Standard: Configuration Precedence (Service-Level overrides). Requirement: Required (core feature for multi-env support). Status: Implemented – The manifest parser and hydrator apply environment defaults and support ${env:*} interpolation (per design examples).

Flexibility – Overrides & Patches: Confirm that the platform’s extensibility mechanisms are working and governed. Validation: Test that a component’s overrides block (allow-listed L2 properties) can successfully override defaults without breaking compliance (e.g. override a Lambda’s memory size or an RDS parameter). Also, verify that a patches.ts file, if present, is applied on top of the synthesized stack and that its changes are captured in an audit log or plan diff. In FedRAMP modes, ensure any patch usage is flagged for review (e.g. requires manual approval in CI). Standard: FR-12 (overrides block); FR-13 (patches escape hatch); AC-R2 (patches logged); AC-R3 (FedRAMP-high patches gated). Requirement: Required (overrides allowed, patches logged; FedRAMP-high requires approval). Status: Partially Implemented – Override logic in place; patches mechanism exists (audit logging of patch changes implemented in plan output); FedRAMP patch approval not yet automated (requires CI integration).

Documentation & Schema: Ensure each component is accompanied by up-to-date documentation and schema. Validation: Check that each packages/<component>/ folder includes a README.md explaining usage and that each component exposes a JSON Schema for its config (e.g. Config.schema.json with all properties and descriptions). These schemas should be aggregated into the platform’s master schema for svc validate. Standard: Contribution guidelines (component contract & schema). Requirement: Suggested (for developer experience and validation). Status: Implemented – Core components have schemas and documentation; Enforced – svc validate uses these schemas (failing if docs/schema not updated).


System-Level Checks

Manifest Schema & Validation: Verify the platform refuses invalid manifests. Validation: Create a sample service.yml missing a required top-level field (e.g. complianceFramework) and run svc validate or svc plan. It should fail with a clear error pointing to the missing field. Similarly, test an invalid value (wrong type, unknown property) and expect a schema validation error with line number/path. Standard: AC-E1 (schema validation must catch missing/invalid fields). Requirement: Required. Status: Implemented – Master JSON Schema composed from component schemas is in use; errors reference the exact location of the issue.

Compliance Framework Selection: Ensure that specifying a compliance framework in the manifest triggers the corresponding rules. Validation: Run svc plan on a service with complianceFramework: fedramp-high. The output should clearly indicate “Active Framework: fedramp-high” and load the FedRAMP-High policy pack for evaluation. Try the same with commercial and fedramp-moderate to ensure proper pack loading. Standard: AC-E2 (load FedRAMP policy pack when requested); AC-E3 (output shows active framework). Requirement: Required. Status: Implemented – Governance engine applies appropriate rules per framework, and CLI output includes the active framework label.

Policy-as-Code Enforcement: Confirm that the Governance Engine (OPA or cdk-nag based) enforces framework-specific rules. Validation: In a FedRAMP Moderate context, introduce a configuration that violates a known FedRAMP control (e.g. an S3 without access logging, or a public subnet without approval) and run plan – it should fail with a critical error referencing the control. In a Commercial context, the same config should pass (perhaps with a warning logged). Verify that all required FedRAMP technical controls (encryption, logging, tagging, etc.) are either automatically applied or cause failures if missing. Standard: AC-G1 (framework-based leniency); AC-G2 (strict FedRAMP enforcement). Requirement: Required. Status: Implemented – Policy packs differentiate Commercial vs FedRAMP (e.g., deletion protection optional in commercial but mandatory in FedRAMP).

Build/CI Integration: Verify the platform’s checks are integrated into CI/CD pipelines. Validation: Ensure that svc plan (or equivalent validation) runs as part of pull request checks for service manifests, preventing merges if compliance violations exist. Confirm that any critical FedRAMP violations or missing justifications cause pipeline failures (non-zero exit codes). Check that on deployment (svc up in CI), any patch files trigger the required workflow (e.g. gating for approval in FedRAMP). Standard: FR-9 (fail builds on FedRAMP violations); AC-R3 (FedRAMP manual approval for patches). Requirement: Required (FedRAMP-high), Suggested (commercial). Status: Partially Implemented – CLI returns proper codes for CI use, and FedRAMP policy failures halt deployment; Pending – automated approval gating for high-security patches.

Central Logging & Audit Artifacts: Ensure that all compliance artifacts are centrally collected. Validation: After running svc plan or svc up, check that outputs like plan JSON, outputs.json, and patch reports are generated and, for FedRAMP, stored in an immutable location (e.g. uploaded to a central logging S3 bucket or security account). Verify that suppression justifications and patch usages appear in an audit log (which could be part of plan output or a separate artifact). Standard: NFR-4 (audit artifacts immutable & in central account); FR-8 (audit log all suppressions/patches). Requirement: Required (FedRAMP-high). Status: Partially Implemented – outputs.json is produced on deploy, and patch/suppression info is included in plan results; Needs Implementation – automatic upload to central log account (currently a manual or future step).

CLI UX – Help & Documentation: Test the CLI for user-friendliness. Validation: Run svc --help and each subcommand with --help, ensuring usage info and examples are displayed (per FR-CLI-1). Verify the CLI prompts for svc init guide the user interactively and produce the expected scaffold (manifest, patches.ts, etc.). Ensure error messages from CLI are clear and actionable (e.g. include file/line if a parse or validation error). Standard: CLI Spec (predictable help output, clear errors). Requirement: Suggested (DevEx). Status: Implemented – CLI has help for all commands and proper error handling as per spec; continuing to monitor UX improvements.

CLI Output Modes: Validate structured output for pipeline use. Validation: Run svc plan --ci and confirm that all output is in JSON format suitable for machine parsing (no color codes or human-only text). Test --verbose logging yields debug details without breaking JSON (likely --verbose is for human mode only). Standard: FR-CLI-3 (CI mode JSON output). Requirement: Required (for CI integration). Status: Implemented – CI flag triggers JSON structured logs; verify in code outputs.

CLI Performance: While hard to verify in code review, ensure the CLI meets performance NFRs. Validation: Running svc validate/plan on a moderately complex service should complete in under ~10 seconds (non-deploy). Full svc up (deploy) on a reasonable stack should not exceed 15 minutes barring external CloudFormation slowness. Standard: NFR-1 (CLI timing). Requirement: Suggested. Status: Not Verified – (Operational metric; monitor during testing).

Dependency Hygiene: Check for outdated or vulnerable dependencies in the repository. Validation: Audit the package.json of each package for any deprecated libraries or severe known vulnerabilities (e.g. run npm audit). Ensure AWS CDK is v2 and consistently used across all packages (no mix of v1). Confirm internal package versions are in sync and peer dependencies (like @platform/contracts) are correctly versioned. Standard: Architectural standard (monorepo with independent versioning). Requirement: Suggested (security & stability best practice). Status: Implemented – Uses AWS CDK v2; no known vulnerable packages (ongoing maintenance required).

Backward Compatibility & Deprecation: Ensure no usage of deprecated patterns within the repo. Validation: Search code for any deprecated AWS CDK APIs or old constructs (should be using modern CDK v2 equivalents). Confirm that the platform has a strategy for deprecating its own components (e.g. marking an older component version as deprecated). While the automated deprecation tool is pending, ensure the codebase does not reference removed features or TODOs for deprecation without handling. Standard: Platform Deprecation Standard (vision for safe removals). Requirement: Suggested (good practice). Status: No current deprecations – All components are current; deprecation workflow tooling is not yet implemented (see backlog).


Services, Bindings, and Utilities

Binding Strategies – Coverage: Verify that all supported binding combinations are implemented as per the Binder Matrix. Validation: For each source component type and capability in the matrix (Lambda->SQS, Lambda->RDS, Lambda->S3, Lambda->DynamoDB, Lambda->SNS, Lambda->Kinesis; EC2->SQS, RDS, S3, Kinesis; ECS->SQS, RDS, S3) ensure a corresponding Binder class exists (e.g. LambdaToSqsBinder, LambdaToRdsBinder, etc.). Check that new or less common combos (ECS, EC2 binders) are stubbed or planned if not in current scope. Standard: Platform Binding Spec (Binder Matrix). Requirement: Required (to support all documented binds). Status: Implemented for core Lambda binders; Partial for EC2/ECS (likely planned, ensure tracking for those not yet in repo).

Binding Strategies – IAM & Networking: Inspect each binder’s implementation for correctness. Validation: For IAM, confirm that binders grant only the minimal AWS IAM actions needed for the specified access level. For example, LambdaToS3Binder: access: read grants s3:GetObject (and ListBucket if needed) on the target bucket, while write grants s3:PutObject (and perhaps DeleteObject). LambdaToRdsBinder: grants permission to retrieve the RDS instance’s secret (SecretsManager GetSecretValue) and configures a security group rule allowing the Lambda’s SG to talk to the DB SG on the port (5432). Validate similar fine-grained access for other binders (SQS read -> sqs:ReceiveMessage & DeleteMessage, write -> sqs:SendMessage; SNS publish -> sns:Publish; DynamoDB read -> dynamodb:GetItem/Query, write -> PutItem/DeleteItem, etc.). Standard: Least privilege binding (Acceptance AC-R1). Requirement: Required. Status: Implemented – Binder classes follow access mappings; confirmed via audit examples (unused permissions flagged).

Binding Strategies – Multi-bind Handling: Verify the platform supports multiple components binding to one target. Validation: Declare two Lambdas both binding to the same SQS queue (one with read, one with write) and ensure the resolver creates two distinct IAM policies and any necessary queue access configs without conflict. The model should simply apply the binder logic for each bind entry independently. Standard: Binding Spec 2.2 (many-to-one binds). Requirement: Required (core functionality). Status: Implemented – The engine processes each binding entry separately (no known issues; covered in design).

Triggers Configuration: Ensure the triggers mechanism on resource components is implemented. Validation: For a resource like S3 bucket with a triggers array, verify the component’s synth logic looks up the target component and creates the appropriate subscription/destination. For example, S3 triggering a Lambda should result in an s3n.LambdaDestination with invoke permissions for the Lambda; SNS triggering multiple SQS queues should create multiple sns.Subscription resources. Check that unsupported trigger combinations are either gracefully ignored or explicitly validated (only those in the Trigger Matrix are allowed). Standard: Trigger Matrix spec. Requirement: Required (for event-driven integration). Status: Implemented – S3, SNS, EventBridge components have trigger handling per spec; verify via unit tests or sample manifest.

Core Engine – Resolver Logic: Inspect the core engine (package core-engine) for end-to-end resolution. Validation: Ensure that the Resolver (or main synth engine) iterates through all components, instantiating each component class with the hydrated config, applying binds (running binder strategies), and applying any triggers. Confirm that it tags the Stack with standard tags at the end. Check that ComponentRegistry or factory loads all component modules (especially in a plug-in model) so no component is missing at runtime. Standard: Architectural design (package-per-component discovery). Requirement: Required. Status: Implemented – Core resolver/registry in place; dynamic loading of components supported (e.g. via naming conventions or manifest registry).

Core Engine – Diff & Plan: Ensure that the svc plan command generates the correct outputs (without deploying). Validation: After running plan, confirm that an infrastructure diff is shown (or in JSON, a list of changes). If cost estimation integration is planned, verify if cost is displayed (per PRD, cost estimate should be part of plan output). If not yet implemented, mark as backlog. Standard: PRD FR-2 (infra diff, cost in plan). Requirement: Suggested. Status: Plan Diff Implemented (via CDK diff); Cost Estimate Pending (cost integration not in current version).

CLI – Local Development: If svc local up is implemented, ensure it works for supported components. Validation: Test svc local up on a manifest with a Lambda and a database/queue – it should start local Docker containers (LocalStack or similar) for dependencies (SQS, Postgres, etc.) as described in FR-4. Verify that environment variables or endpoints are configured such that the Lambda can connect to these local resources. Standard: PRD FR-4 (Local emulation via Docker/LocalStack). Requirement: Suggested (DevEx). Status: Not Implemented – Feature planned but not present in current repo (to revisit in future QA).

Internal Utilities: Check any utility libraries (e.g. contracts package, config loaders, etc.). Validation: Ensure the contracts package defines clear interfaces/types for component specs, and that these are used across components to ensure consistency (e.g. IComponentSpec, JSON schema generation). If there is an IAM policy construct utility, confirm it standardizes tagging or naming of policies. If an environment config loader exists, ensure it validates the presence of required fields (account, region, etc.). Standard: Internal coding standards (consistency, reuse). Requirement: Suggested. Status: Implemented – Shared types and helpers exist (reviewed via package contents); continue to enforce usage to prevent drift.

Developer Experience Features: (Optional checks) If any DevEx tooling from the design is present (e.g. VSCode extension integration hooks, svc generate component), verify their alignment. For example, if svc generate component exists, ensure it produces a new package scaffold with all necessary files (schema, tests, binder stub, etc.) as per design. Standard: DevEx idea (Component Generator). Status: Likely Not Implemented (future feature; include for completeness if partially present).


PENDING_SKIP – Backlog & Unenforced Checks

(The following are plausible checks not currently enforced, flagged for backlog consideration.)

PENDING_SKIP: Comprehensive IAM Audit Tool – Implement the svc audit iam command to automatically compare granted vs used IAM permissions. Currently not enforced; when built, it should flag any unused permissions on a component’s role within a given timeframe and suggest removal. Status: Not yet implemented (backlog).

PENDING_SKIP: Automated Deprecation Analysis – Complete the svc audit dependencies CLI and MCP integration for deprecation. This would allow querying which services depend on a given component before its removal. No runtime checks yet; future enforcement could require running this audit before certain destructive changes. Status: Design exists, not in code.

PENDING_SKIP: FedRAMP Continuous Monitoring – Integrate additional FedRAMP-high controls that are not yet automated, such as:SCPs to prevent untagged resource creation (org-level), AWS Config rules for drift detection, and GuardDuty for continuous security monitoring. These are currently outside platform code but are recommended for compliance. Status: Not enforced by platform (rely on cloud ops).

PENDING_SKIP: Enhanced Structured Logging – Provide or enforce a standard logging library for application code (e.g. a platform logging SDK or Lambda Powertools) to ensure JSON log output with required fields (user IDs, request IDs, etc.). While the platform sets an expectation, it doesn’t yet verify the structure of application logs. Status: Not implemented (backlog – could integrate with runtime templates).

PENDING_SKIP: Centralized Audit Log Shipping – Automate the export of CloudTrail, RDS audit logs, and other audits to the central logging account. AC-C3 requires RDS audit logs to go to a central account, but implementation likely manual. Platform could automate log routing (e.g. CloudWatch Subscription to central SIEM) in future. Status: Not in current scope.

PENDING_SKIP: Performance Budget Enforcement – No current check on whether a service exceeds certain size or cost. Future idea: warn if a single service is provisioning unusually large resources beyond expected bounds (to catch misconfigurations). Status: Not implemented (observation only).

PENDING_SKIP: Orphan Resource Detection – In future, platform could track resources not covered by manifests (drift). This is not enforced now but tools could be added to flag resources in an account that lack the standard tags (hence likely not managed by the platform). Status: Backlog idea (leveraging tags and CMDB).

PENDING_SKIP: DevEx IDE Integration – While not affecting compliance, a VSCode extension was envisioned. Ensure any partial implementations (e.g. JSON schema publishing for auto-complete) are monitored, and include its validation steps when it comes online.



---

Sources: The checklist items above reference the platform’s official standards and specifications, including the Platform Tagging Standard, OpenTelemetry Observability Standard, Security/IAM Standards, Configuration Precedence design, Product Requirements Document (PRD), and FedRAMP-related acceptance criteria. These sources define the required checks and have been cited inline for each item.

Post-Developmen.txt
Displaying Post-Developmen.txt.